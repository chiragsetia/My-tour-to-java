/*The span si of a stockâ€™s price on a certain day i is the minimum number of consecutive days (up to the current day) the price of the stock has been less than its price on that ith day. If for a particular day, if no stock price is greater then just count the number of days till 0th day including current day.
For eg. if given price array is {3, 6, 8, 1, 2}, span for 4th day (which has price 2) is 2 because minimum count of consecutive days (including 4th day itself) from current day which has price less than 4th day is 2 (i.e. day 3 & 4). Similarly, span for 2nd day is 3 because no stock price in left is greater than 2nd day's price. So count is 3 till 0th day.
Given an input array with all stock prices, you need to return the array with corresponding spans of each day.*/
 
 
 
 
 
 public static int[] stockSpan(int[] price) {
        int [] arr=new int[price.length+1];
        int [] rArr=new int[price.length];
        int prv=0;
        for(int i=1;i<price.length+1;i++){
            if(price[i-1]>prv){
                arr[i]=1;
                int j=i-1;
                while(j>0&&price[i-1]>price[j-1]){
                    arr[i]+=arr[j];
                    j-=arr[j];
                }
            }else{
                arr[i]=1;
            }
            prv=price[i-1];
        rArr[i-1]=arr[i];
        }
        return rArr;
    }


/*Check redundant brackets
Level MEDIUM
Given a string mathematical expression, return true if redundant brackets are present in the expression. Brackets are redundant if there is nothing inside the bracket or more than one pair of brackets are present.
Assume the given string expression is balanced and contains only one type of bracket i.e. ().
Note: You will not get partial score for this problem. You will get marks only if all test cases are passed.

*/

import java.util.Stack;

public class solution {
	
	public static boolean checkRedundantBrackets(String input) {
		Stack<Character> s=new Stack<>();
        int flag=0;
        for(int i=0;i<input.length();i++){
            if(input.charAt(i)==')'){
                if(s.isEmpty()||s.peek()=='('){
                    return true;
                }
                while(!s.isEmpty()&&s.pop()!='(');
            }else{
                s.push(input.charAt(i));
            }
         
        }
        return false;
	}
}


/*Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
Please refer to Sample test case for more details.
*/

import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
    	Scanner sc=new Scanner(System.in);
    	int n=sc.nextInt();
    	int arr[]=new int[n];
    	for (int i=0;i<n ;i++ ) {
    		arr[i]=sc.nextInt();
    	}
    	int s=firstNonZero(arr);
    	System.out.println(water(arr,s));
    }
    private static int firstNonZero(int arr[]){
    	int i;
    	for(i=0;i<arr.length;i++){
    		if(arr[i]!=0){
    			break;
    		}
    	}
    	return i;
    }
    private static int water(int arr[], int s){
    	if(s>=arr.length){
    		return 0;
    	}
    	int large=s+1;
    	for(int i=s+1;i<arr.length;i++){
    		if(arr[s]<arr[i]){
    			large=i;
    			break;
    		}else if(arr[i]>arr[large]){
    			large=i;
    		}
    	}
    	int sum=0;
    	if(large-s==1){
    		return water(arr,large);
    	}
    	int min =Math.min(arr[s],arr[large]);
    	for(int i=s+1;i<large;i++){
    		sum+=min-arr[i];
    	}
    	int anotherSum=water(arr,large);
    	return sum+anotherSum;
    }

}
