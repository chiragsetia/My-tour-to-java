//There are N chocolates on the table. The teacher is distributing the chocolates one by one. Mannerless and hungry children don’t wait for their chance and come again and again for the chocolates. The teacher is looking over this. She scolds a child if at a given time, the child has already taken more chocolates than count of all the chocolates with other children.

//17 April,2019

import java.util.*;

public class Main {

	
	public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
		HashMap<String,Integer> map=new HashMap<>();
        int total=1;
        int n=sc.nextInt();
        int scold=0;
        map.put(sc.next(),1);
        for(int i=1;i<n;i++){
            String t=sc.next();
            if(map.containsKey(t)){
                if(map.get(t)>total-map.get(t))
                	scold++;
                map.put(t,map.get(t)+1);
                //total++;
            }else{
                map.put(t,1);
            }
            total++;
        }
        System.out.println(scold);
	}

}


/*This summer, Ghanshyam is teaching web development to a class of N students. There are K classes in the course. Each day, he comes to the class, he teaches a new topic to the class, about which his students have never heard of. When he doesn’t come to the class, students discuss within themselves all the topics that they know.
For each of the K classes, you are provided with roll numbers of the present participants of the course. Your task is to print the roll numbers of the participants who know all the topics discussed in the course.
Note: Ghanshyam is also given a roll number. By default, he is given the roll number 1.*/

import java.util.*;

public class Main {

	
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
    	int k=sc.nextInt();
        int value=0;
        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<k;i++){
            Set<Integer> set=new HashSet<>();
            int flag=0;
            int s=sc.nextInt();
            int max=Integer.MIN_VALUE;
            for(int j=0;j<s;j++){
                int r=sc.nextInt();
                if(r==1){
                    flag=1;
                }else{
                    set.add(r);
                    if(map.containsKey(r)&&max<map.get(r)){
                        max=map.get(r);
                    }
                }
            }
            for(Integer j:set){
                if(flag==0){
                    map.put(j,max);
                }else{
                    if(map.containsKey(j))
                    map.put(j,map.get(j)+1);
                    else
                       map.put(j,1);
                }
            }
            if(flag==1){
                value++;
            }
        }
        System.out.println("1");
        Set<Integer> set=map.keySet();
        for(Integer i:set){
            if(value==map.get(i)){
                System.out.println(i);
            }
        }
        
    }

}


/* On a Sunday morning, some friends have joined to play: Game of Names. There is an N x N board. Each player is playing, turn by turn. At the turn of ith player, the player places first character of its name at one of the unfilled cells. The first player who places its character for 3 consecutive vertical, horizontal or diagonal cells is the winner.
You are provided a board with some filled and some unfilled cells. You have to tell the winner. If there is no winner, then you must print “ongoing”.*/

import java.util.Scanner;// dependencies

public class Main {

	
	public static void main(String[] args) {
	Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr1[][]=new int[n][n];
        int arr2[][]=new int[n][n];
        int arr3[][]=new int[n][n];
        int arr4[][]=new int[n][n];
        char carr[][]=new char[n][n];
        for(int i=0;i<n;i++){
            carr[i]=sc.next().toCharArray();
        }
		for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(carr[i][j]=='.')
                    continue;
                if(j>0&&carr[i][j]==carr[i][j-1])
                    arr1[i][j]=Math.max(arr1[i][j-1]+1,arr1[i][j]);
                if(j>0&&i>0&&carr[i-1][j-1]==carr[i][j])
                    arr2[i][j]=Math.max(arr2[i-1][j-1]+1,arr2[i][j]);
                if(i>0&&carr[i-1][j]==carr[i][j])
                    arr3[i][j]=Math.max(arr3[i-1][j]+1,arr3[i][j]);
                if(i>0&&j<n-1&&carr[i-1][j+1]==carr[i][j])
                    arr4[i][j]=Math.max(arr4[i-1][j+1]+1,arr4[i][j]);
                if(arr1[i][j]==2||arr2[i][j]==2||arr3[i][j]==2||arr4[i][j]==2){
                    System.out.println(carr[i][j]);
                    return;
                }
            }
        }
        System.out.println("Ongoing");
	}
}

/* Navdeep saw strange houses on one side of NH-1. He saw that houses were covered by an extra layer of walls at the starting and the ending. Lawns were also protected by these extra layer of walls.
Immediately, he made a sketch. He used parentheses to denote walls. For example: a house in his sketch was shown as: (()()) and a lawn was shown as ().
After he reached home, he forgot which were protective walls and which were real layers of wall of house. He need your help. He is giving you his sketch in the form of String. Your task is to print string after removing the outermost parentheses or wall of every house or lawn.
Note: Each opening parentheses is complimented by closing parenthesis.*/


import java.util.Scanner;

public class Main {

	
	public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        //Stack<Character> stack=new Stack<>();
        String s=sc.next();
        int flag=0;
        String ans="";
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='('&&flag==0){
                flag=1;
            }else if(s.charAt(i)==')'&&flag==1){
                flag=0;
                System.out.print(ans);
                ans="";
            }else if(s.charAt(i)=='('){
                flag++;
                ans+=s.charAt(i);
            }else{
				flag--;
                ans+=s.charAt(i);
            }
        }
	}

}

/*There were two towns in Assam, where disastrous floods came. The connectivity between them was lost and they seemed as 2 islands from above. Arpan wanted to help. He drew a map of town on a 2D binary array. There were 2 values in the 2D array: o and 1. 1 represented land and 0 represented water.
Arpan explained how he denoted a symbolised land of a town on binary matrix. According to him, those 1 valued cells which were reachable by other such cells, through either of the 4-directions, constituted a town. You are given 2 such towns in the input matrix.
Now, Arpan wants to connect two towns, by changing 0s to 1s.
Your task is to print the smallest number of 0s that must be reversed to connect two towns.*/




import java.util.*;

class pair{
    int a;
    int b;
    pair(int a,int b){
        this.a=a;
        this.b=b;
    }
}
public class Main {

	
	public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        ArrayList<pair> list =new ArrayList<>();
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(sc.nextInt()==1)
                {
                    list.add(new pair(i,j));
                }
            }
        }
        pair j=null;
        int k=0;
        ArrayList<pair> list2 =new ArrayList<>();
        
        int min=Integer.MAX_VALUE;
        for(pair i:list){
            if(k==0){
                k++;
                j=i;
                list2.add(i);
                continue;
            }
            if(ans(list2,i)==1){
                list2.add(i);
                j=i;
                continue;
            }
            min=Math.min(min,Math.abs(i.a-j.a)+Math.abs(i.b-j.b));
            
        }
        System.out.println(min-1);
       	//Math.abs(arr[0][0]-arr[1][0])+Math.abs(arr[0][1]-arr[1][1])
	}
    private static int ans(ArrayList<pair> list,pair j ){
        for(pair i:list){
            if(Math.abs(i.a-j.a)+Math.abs(i.b-j.b)==1){
                return 1;
            }
        }
        return 0;
    }

}
